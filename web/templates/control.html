{% extends "base.html" %}

{% block title %}수동 조작 - HappyCircuit{% endblock %}

{% block content %}

{% block styles %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/control.css') }}">
{% endblock %}
</head>
<body>

<h1>로봇 조종기</h1>
<div id="status">연결 안됨</div>

<div class="d-pad">
  <div id="forward" class="button forward">↑</div>
  <div id="left" class="button left">←</div>
  <div id="stop" class="button stop">■</div>
  <div id="right" class="button right">→</div>
  <div id="backward" class="button backward">↓</div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script>
  // DOM이 완전히 로드된 후 스크립트 실행
  document.addEventListener('DOMContentLoaded', () => {
    // 0. 전역변수 설정
    let isRobotConnected = false;
    // 1. 서버의 웹소켓에 연결
    const socket = io();
    const statusDiv = document.getElementById('status');
    // 입력 이벤트를 처리하기 위한 버튼 인식
    const allControlButtons = document.querySelectorAll('.d-pad .button');

    // 2. 연결 이벤트 처리
    socket.on('status_update', (data) => {
      // 서버에서 보낸 robot_status 객체에서 실제 로봇 연결 상태를 확인

      isRobotConnected = data.pi_slam.rosbridge_connected;

      console.log('상태 업데이트 수신:', data); // 디버깅용 로그

      if (isRobotConnected) {
        console.log('서버에 성공적으로 연결되었습니다!');
        statusDiv.textContent = '연결됨';
        statusDiv.style.backgroundColor = '#28a745'; // 초록색
      } else {
        console.log('서버와의 연결이 끊어졌습니다.');
        statusDiv.textContent = '연결 안됨';
        statusDiv.style.backgroundColor = '#dc3545'; // 빨간색
      }
    });

    // 3. 제어 명령을 서버로 보내는 함수
    function sendCommand(direction) {
      if (!isRobotConnected) {
        console.log('서버와의 연결이 끊어졌습니다.');
        statusDiv.textContent = '연결 안됨';
        statusDiv.style.backgroundColor = '#dc3545'; // 빨간색
        alert('로봇과 연결되지 않았습니다.\n서버 및 로봇의 상태를 확인해주세요.');
        return; // 연결이 안 됐으면 여기서 함수 실행 중단
      }

      console.log(`명령 전송: ${direction}`);
      socket.emit('drive_command', { 'direction': direction });

      // --- UI 업데이트 로직 ---
      // 1. 먼저 모든 버튼의 활성 상태를 초기화
      allControlButtons.forEach(btn => btn.classList.remove('active-command'));

      // 2. 현재 명령에 맞는 버튼을 찾아 활성 클래스 추가
      if (direction !== 'stop') {
        const activeButton = document.getElementById(direction);
        if (activeButton) {
          activeButton.classList.add('active-command');
        }
      } else {
        const stopButton = document.getElementById('stop');
        if (stopButton) {
          stopButton.classList.add('active-command');
          setTimeout(() => {
            stopButton.classList.remove('active-command');
          }, 200);
        }
      }
    }

    // 4. 각 버튼에 이벤트 리스너(이벤트 처리기) 추가
    //    - 마우스를 누르면 해당 방향으로, 떼면 'stop' 명령 전송
    //    - 모바일 터치도 동일하게 지원
    const buttons = [
      { id: 'forward',  direction: 'forward' },
      { id: 'backward', direction: 'backward' },
      { id: 'left',     direction: 'left' },
      { id: 'right',    direction: 'right' }
    ];

    buttons.forEach(btnInfo => {
      const element = document.getElementById(btnInfo.id);

      // 데스크탑용 마우스 이벤트
      element.addEventListener('mousedown', () => sendCommand(btnInfo.direction));
      element.addEventListener('mouseup', () => sendCommand('stop'));
      element.addEventListener('mouseleave', () => sendCommand('stop')); // 버튼 영역 밖으로 마우스가 나가도 정지 (안전 기능)

      // 모바일용 터치 이벤트
      element.addEventListener('touchstart', (event) => {
        event.preventDefault(); // 터치 시 화면이 스크롤되는 기본 동작 방지
        sendCommand(btnInfo.direction);
      });
      element.addEventListener('touchend', () => sendCommand('stop'));
    });

    // 정지 버튼은 한 번 클릭하는 것으로 동작
    document.getElementById('stop').addEventListener('click', () => sendCommand('stop'));

    // 키보드 조작으로도 로봇이 조작 가능하도록 인식되는 버튼을 추가
    let keydownState = {};
    document.addEventListener('keydown', (event) => {
      // 이미 해당 키가 눌려있으면 중복 실행 방지
      if (keydownState[event.key]) {
        return;
      }
      keydownState[event.key] = true;

      // 키에 따라 다른 명령 전송
      switch (event.key) {
        case 'w':
        case 'W':
        case 'ㅈ':
        case 'ArrowUp':
          sendCommand('forward');
          break;
        case 'x':
        case 'X':
        case 'ㅌ':
        case 'ArrowDown':
          sendCommand('backward');
          break;
        case 'a':
        case 'A':
        case 'ㅁ':
        case 'ArrowLeft':
          sendCommand('left');
          break;
        case 'd':
        case 'D':
        case 'ㅇ':
        case 'ArrowRight':
          sendCommand('right');
          break;
        case 's':
        case 'S':
        case 'ㄴ':
        case ' ': // 스페이스바
          sendCommand('stop');
          break;
      }
    });

    document.addEventListener('keyup', (event) => {
      // 키 눌림 상태 해제
      keydownState[event.key] = false;

      // 어떤 키에서든 손을 떼면 'stop' 명령을 보내 안전하게 정지
      // (단, 정지 키 자체는 제외하여 불필요한 중복 명령 방지)
      const stopKeys = ['s', 'S', 'ㄴ', ' '];
      if (!stopKeys.includes(event.key)) {
        sendCommand('stop');
      }
    });
  });
</script>
</body>
{% endblock %}